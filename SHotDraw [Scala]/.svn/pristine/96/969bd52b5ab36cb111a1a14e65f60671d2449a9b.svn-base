/*
 * @(#)UndoableAdapter.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	? by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */
package org.jhotdraw.util

import org.jhotdraw.framework.DrawingView
import org.jhotdraw.framework.Figure
import org.jhotdraw.framework.FigureEnumeration
import org.jhotdraw.standard.FigureEnumerator
import org.jhotdraw.standard.ReverseFigureEnumerator
import org.jhotdraw.standard.StandardFigureSelection

/**
 * Most basic implementation for an Undoable activity. Subclasses should override
 * methods to provide specialized behaviour when necessary.
 *
 * @author  Wolfram Kaiser <mrfloppy@sourceforge.net>
 * @version <$CURRENT_VERSION$>
 */
class UndoableAdapter extends Undoable {
  def this(newDrawingView: DrawingView) {
    this()
    setDrawingView(newDrawingView)
  }

  /**
   * Undo the activity
   * @ true if the activity could be undone, false otherwise
   */
  def undo: Boolean = isUndoable

  /**
   * Redo the activity
   * @ true if the activity could be redone, false otherwise
   */
  def redo: Boolean = isRedoable

  def isUndoable: Boolean = myIsUndoable

  def setUndoable(newIsUndoable: Boolean) {myIsUndoable = newIsUndoable}

  def isRedoable: Boolean = myIsRedoable

  def setRedoable(newIsRedoable: Boolean) {myIsRedoable = newIsRedoable}

  def setAffectedFigures(newAffectedFigures: FigureEnumeration) {
    if (newAffectedFigures == null) {
      throw new IllegalArgumentException
    }
    rememberFigures(newAffectedFigures)
  }

  def getAffectedFigures: FigureEnumeration = {
    if (myAffectedFigures == null) new FigureEnumerator(List[Figure]())
    else new FigureEnumerator(myAffectedFigures)
  }

  def getAffectedFiguresReversed: FigureEnumeration = new ReverseFigureEnumerator(myAffectedFigures)

  def getAffectedFiguresCount: Int = myAffectedFigures.size

  protected def rememberFigures(toBeRemembered: FigureEnumeration) {
    myAffectedFigures = List[Figure]()
    toBeRemembered foreach { e =>
      myAffectedFigures ::= e
    }
  }

  /**
   * Releases all resources related to an undoable activity
   */
  def release {
    getAffectedFigures foreach { e => e release}
    setAffectedFigures(FigureEnumerator.getEmptyEnumeration)
  }

  /**
   * Create new set of affected figures for redo operation because
   * deleting figures in an undo operation makes them unusable
   * Especially contained figures have been removed from their
   * observing container like CompositeFigure or DecoratorFigure.
   * Duplicating these figures re-establishes the dependencies.
   */
  protected def duplicateAffectedFigures {
    setAffectedFigures(StandardFigureSelection.duplicateFigures(getAffectedFigures, getAffectedFiguresCount))
  }

  def getDrawingView: DrawingView = {
     myDrawingView
  }

  protected def setDrawingView(newDrawingView: DrawingView) {
    myDrawingView = newDrawingView
  }

  private var myAffectedFigures: List[Figure] = null
  private var myIsUndoable: Boolean = false
  private var myIsRedoable: Boolean = false
  private var myDrawingView: DrawingView = null
}